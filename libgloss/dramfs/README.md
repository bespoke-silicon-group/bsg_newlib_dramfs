# Newlib/DRAMFS  
###### Bandhav Veluri and Michael Taylor, Bespoke Silicon Group UW  

## Introduction

Newlib is a light-weight C standard library implementation for embedded systems. It elegantly separates system specific functionality (system calls) into an easily portable portion called Libgloss. Libgloss contains system call implementations for different architectures/systems in it. Porting Newlib to an architecture/system essentially involves porting these system call implementations in Libgloss. Complete guide for porting Newlib can be found here.

Running POSIX programs on bare metal systems require some sort of implementation for file i/o and malloc. Malloc depends on just one system-call called sbrk, which essentially increments or decrements heap pointer as and when requested. Whereas, file i/o requires an actual file system, or an interface that can mimic a file system. This Newlib port uses an open-source lightweight file-system designed for embedded flash file systems by ARM called LittleFS (LFS). LittleFS also supports a DRAM-based file system, which is the one we use. 

The idea is to implement file i/o syscalls by simply translating them to LFS function calls, which in turn will operate on memory, rather than trying to use a more complex I/O emulation facility, like proxy kernels, that package up I/O calls and ship them over to a host. This allows for more reproducible I/O emulation, since the host is no longer an asynchronous process. It also eliminates the infrastructure pain caused by mapping these proxy-IO calls to different embodiments of the design -- simulator, VCS, verilator, FPGA emulation, ASIC testboard, and PCI-e hosted chip.

## Installation

Newlib/Dramfs is intended to be a separate Board Support Package (BSP) in Newlib and we plan to upstream it to Newlib. But currently, this project can be used with RISC-V GCC toolcahin by replacing the newlib submodule with this repository. RISC-V toolchain with Newlib/Dramfs can be installed as below:

```
git clone --recursive https://github.com/riscv/riscv-gnu-toolchain.git
cd riscv-gnu-toolchain
git config --file=.gitmodules submodule.riscv-newlib.url https://github.com/bespoke-silicon-group/bsg_newlib_dramfs.git
git config --file=.gitmodules submodule.riscv-newlib.branch dramfs
git submodule sync
git submodule update --init --recursive --remote riscv-newlib
make newlib
make install
```

## Porting

Porting Newlib/Dramfs to a RISC-V system requires following four steps:
1. Implement `dramfs_exit(int)` (routine to exit the execution environment). 
2. Implement `dramfs_sendchar(char)` (routine to output non-file I/O (for debugging etc))
3. Call `dramfs_fs_init()` in the crt.
4. Define `_end` symbol (heap pointer) in the linker command file.

#### 1, 2. Interfacing functions:
```
// Sample Implementation of Newlib/DRAMFS interface
// dramfs_intf.c

#include <stdlib.h>

/*  Prototype in this repo: extern void dramfs_exit(int)
    Exit the simulation/runtime environment
 */
void dramfs_exit(int exit_status){
  if(exit_status == EXIT_SUCCESS)
    // Exit the environment successfully
  else
    // Exit the environment with failure
}


/*  Prototype in this repo: extern void dramfs_sendchar(char)
    Displays a char on the console
 */
void dramfs_sendchar(char ch) {
  // code to display ‘ch’
  // in many cases you may just want to have a memory
  // mapped I/O location that you write to
  // whether that is simulator magic, a NOC, a UART, or PCIe.
}
```

#### 3. Adding `dramfs_fs_init` call to C-runtime initialization code:

The function `dramfs_fs_init` has to called before calling the main. This steps mounts the LittleFS image using a tiny block device driver implemeted by us. A sample C-runtime initialization is provided below:

```
  # Sample crt.S
  li sp, _sp                      # stack pointer
  call dramfs_fs_init
  bltz ra, 1f
  lw a0, 0(sp)                    # argc
  addi a1, sp, __SIZEOF_POINTER__ # argv
  li a2, 0                        # envp = NULL
  call main
1:
  tail exit
```

#### 4. Defining `_end` symbol in the linker command file:

This can be done as shown in the sample linker script below:

```
/* link.ld */

SECTIONS
{
  . = 0x1000; /* program memory start */
  .text : { *(.text) }
  
  . = 0x80000000; /* data memory start */
  .data : { *(.data) }
  .bss : { *(.bss) }
  
  _end = .; /* head starts after the data */

  _sp = 0xffffffff; /* stack starts from the end */
}
```

## Usage

Running a program with Newlib/Dramfs requires user to link an additional file with initial LittleFS image consisting of input files. LittleFS image can be automatically generated by a tool called `dramfs_mklfs` that has already been installed with this package! The tool needs two inputs `lfs_block_size` and `lfs_block_count`. Total size of the file-system would be `lfs_block_size*lfs_block_count`.

Usage of `dramfs_mklfs`:
```
dramfs_mklfs <lfs_block_size> <lfs_block_count> <input file 1> <input dir 1> <input file 2> ...
```

After installation and porting, the procedure for running programs with Newlib/Dramfs is summarized by a sample program below. Let's say we want to run a file i/o program on a bare metal system which takes `hello.txt` as input.

```
/*
 * fhello.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
  char c;

  // Read from a file
  FILE *hello = fopen("hello.txt", "r");
  if(hello == NULL)
    return -1;

  while((c = fgetc(hello)) != '\n') {
    putchar(c);
  }
  putchar('\n');

  fclose(hello);
  return 0;
}
```

Contents of `hello.txt`:
```
Hello! This is Little FS!
```

```
<toolchain_installtion_dir>/riscv32-unknown-elf/bin/dramfs_mklfs 64 128 hello.txt > lfs_mem.c
<toolchain_installtion_dir>/bin/riscv32-unknown-elf-gcc -c fhello.c -o fhello.o
<toolchain_installtion_dir>/bin/riscv32-unknown-elf-gcc -c lfs_mem.c -o lfs_mem.o
<toolchain_installtion_dir>/bin/riscv32-unknown-elf-gcc -t link.ld fhello.o crt.o lfs_mem.o -o fhello
./fhello
```

## Notes

- Of the syscalls listed in [4], Newlib/Dramfs currently supports `sbrk`, `open`, `close`, `read`, `write`, `exit`, `lseek`. Others are not supported yet, and they return setting appropriate error number.
- Block size and count can be tweaked to imporve performance depending on your system. More on this can be understood from [2].

## References

[1] Bootstrapping Idea: https://drive.google.com/open?id=1_Ie94nZvyvMjEb1GQTPzfcBNaVs6xfVXZ_bHTH5_z3k  
[2] LittleFS: https://github.com/ARMmbed/littlefs  
[3] RISC-V BSP: https://github.com/riscv/riscv-newlib/tree/riscv-newlib-3.1.0/libgloss/riscv  
[4] Newlib OS interface: https://sourceware.org/newlib/libc.html#Syscalls
